## First task
![Alt text](<pic/Screen1.png>)

## Second task
![Alt text](<pic/screen2.png>)

![Alt text](<pic/screen3.png>)

## Third task
Смотрим текущее имя компьютера

![Alt text](<pic/screen4.png>)

Изменить имя хоста Ubuntu можно несколькими способами. Самый простой способ установить имя компьютера, которое сохранится только до перезагрузки можно использовать команду hostname, которой в параметре нужно передать новое имя. Например:
   
    sudo hostname losst-pc

Но после перезагрузки все вернется как было раньше. Чтобы сделать изменения постоянными нужно изменить содержимое двух файлов. /etc/hostname и /etc/hosts:

![Alt text](<pic/screen5.png>)
![Alt text](<pic/1.png>)
![Alt text](<pic/screen6.png>)
![Alt text](<pic/screen7.png>)
![Alt text](<pic/screen8.png>)
![Alt text](<pic/screen9.png>)

Далее изменим часовой пояс. Проверим время на этот момент.

![Alt text](<pic/screen10.png>)


Наиболее популярный и поддерживаемый в большинстве дистрибутивов способ установки часового пояса для всех пользователей - с помощью символической ссылки /etc/localtime на файл нужного часового пояса. Список доступных часовых поясов можно посмотреть командой:

    ls /usr/share/zoneinfo/

![Alt text](<pic/screen11.png>)

Для создания символической ссылки используйте команду ln -sf. Файл зоны нужно выбрать из доступных в системе. Например, мой часовой пояс - Ереван(ну Удмуртия), для установки будет использоваться следующая команда:

 
    ln -sf /usr/share/zoneinfo/Asia/Yerevan /etc/localtime

![Alt text](<pic/screen15.png>)

### Настройка с помощью systemd.
В systemd есть своя утилита для настройки даты и часового пояса. Чтобы узнать текущее состояние :
 
    timedatectl status

![Alt text](<pic/screen12.png>)

Для просмотра всех доступных временных зон выполните такую команду:
   
    timedatectl list-timezones

![Alt text](<pic/screen13.png>)

Для установки нужного часового пояса используйте команду set-timezone.

![Alt text](<pic/screen14.png>)

### Network Interfaces
#### Утилита ifconfig
Утилита ifconfig выводит не только список сетевых интерфейсов, но и информацию о них, такую как состояние, IP адрес, MAC адрес и другие параметры. Для отображения всех интерфейсов достаточно выполнить программу без параметров:

    ifconfig

![Alt text](<pic/screen16.png>)

#### Утилита ip
Программа ifconfig устарела и ей на смену пришла утилита ip. Она объединяет в себе функции нескольких программ, например ifconfig, route, brctl и других. Посмотреть список устройств с помощью ip можно выполнив команду:

    ip link show

![Alt text](<pic/screen17.png>)

Можно вывести информацию в более компактном виде, использовав опцию -br:

    ip -br link show

![Alt text](<pic/screen18.png>)

В таком случае все данные отображаются в одну строчку, выводится состояние, MAC адрес и ещё несколько опций.

lo (loopback device) – виртуальный интерфейс, присутствующий по умолчанию в любом Linux. Он используется для отладки сетевых программ и запуска серверных приложений на локальной машине. С этим интерфейсом всегда связан адрес 127.0.0.1. У него есть dns-имя – localhost. Посмотреть привязку можно в файле /etc/hosts.

enp0s3 ― сетевой адаптер Ethernet.
### Внутренний IP

    ip address

![Alt text](<pic/screen19.png>)

Эта команда позволяет увидеть список IP адресов, мак адресов, интерфейсов и их параметры. А что такое интерфейсы? Физические порты на сетевых адаптерах правильнее называть физическими интерфейсами. А даваемые настройки в операционной системе применяются на программную составляющую этого интерфейса, называемую логическим интерфейсом. И в обычной речи, когда говорят порт, имеют ввиду физический интерфейс, а когда говорят интерфейс - имеют ввиду логический интерфейс. С точки зрения операционной системы мы работаем с интерфейсами, а не с портами. Т.е. вставляешь кабель в порт, а даёшь IP адрес на интерфейс.

Собственно в строке inet видим IP адрес - 10.0.2.15 - это адрес из моей домашней сети. Рядом с ним маска /24 - т.е. в моём случае адрес сети - 10.0.2.0, броадкаст - 10.0.2.255(широковещательный канал, широковещание (англ. broadcasting) — метод передачи данных в компьютерных сетях, при котором поток данных (каждый переданный пакет в случае пакетной передачи) предназначен для приёма всеми участниками сети), а диапазон адресов - от 1 до 254. Чуть ниже строка inet6 - это IP адрес по IPv6.

### Внешний IP

    ifconfig.me 

Это веб-служба, которая отображает информацию о вашем подключении, включая IP-адрес, имя хоста и строку агента пользователя. Полезно, что она предоставляет упрощенный интерфейс, к которому можно легко запросить эту информацию из командной строки.

Команда curl в системах Linux обычно используется для загрузки файлов на удаленный сервер или с него. Еще одна интересная вещь, для которой мы можем ее использовать, - это определение общедоступного IP-адреса нашей системы. Для этого мы можем использовать curl для запроса веб-сайтов, которые настроены на то, чтобы не делать ничего, кроме возврата IP-адреса любой системы, подключающейся к нему. Это один из самых быстрых и простых способов получить ваш общедоступный IP-адрес в командной строке Linux. 

Итак:

    curl ifconfig.me

![Alt text](<pic/screen20.png>)


### DHCP 
(Dynamic Host Configuration Protocol) - это протокол клиента или сервера, который автоматически предоставляет узел протокола IP с его IP-адресом и другие связанные сведения о конфигурации, такие как маска подсети и шлюз по умолчанию.

Для работы по сети любому устройству требуется IP-адрес. В протоколе IPv4 это числовой идентификатор, состоящий из 4 разрядов, каждый из которых отделяется точкой, без него устройство не может быть определено в сетевой инфраструктуре. 
Прикладной протокол DHCP выполняет всю работу по подбору сетевых настроек автоматически, без необходимости присваивать вручную каждому устройству свой IP-адрес. Это очень упрощает работу системного администратора в случае расширения сети.

    hostname -I

![Alt text](<pic/screen22.png>)

hostname используется для отображения DNS-имени системы, а также для отображения или установки ее имени хоста или
доменного имени NIS.

-I [--all-ip-адреса]

Отображать все сетевые адреса хоста. Этот параметр перечисляет все настроенные адреса на всех сетевых интерфейсах. Интерфейс обратной связи и IPv6 link-local адреса опущены. В отличие от опции -i, эта опция не зависит от имени разрешение. Не делайте никаких предположений о порядке вывода.

Задаём статичные данные настройки ip, gw, dns.
gw - шлюз по умолчанию (англ. Default gateway) — узел компьютерной сети (сетевой шлюз в маршрутизируемых протоколах), на который пакет отправляется в том случае, если маршрут к сети назначения пакета не известен (не задан явным образом в таблице маршрутизации хоста или не соответствует IP-адресу назначения пакета.). Применяется в сетях с хорошо выраженными центральными маршрутизаторами, в малых сетях, в клиентских сегментах сетей.

dns -серверы - это серверы, на которых хранится информация о том, какому IP-адресу какое доменное имя соответствует. В некотором роде DNS-сервер можно считать аналогом физической телефонной книги. Кроме того, DNS-серверы позволяют не только хранить информацию о доменных именах и IP-адресах, но и кэшировать ранее запрошенные пользователями IP-адреса.

    vim /etc/netplan/00-installer-config.yaml

#### Netplan
Ubuntu 17.10 и новее использует Netplan в качестве инструмента управления сетью по умолчанию. Предыдущие версии Ubuntu использовали ifconfig и его файл конфигурации /etc/network/interfaces для настройки сети. Файлы конфигурации Netplan записываются в синтаксисе YAML с .yaml файла .yaml .

    До

![Alt text](<pic/screen23.png>)

    После sudo vim /etc/netplan/00-installer-config.yaml

![Alt text](<pic/screen24.png>)

    Пингуем

![Alt text](<pic/screen25.png>)

## Fourth task
    sudo apt update
![Alt text](<pic/screen26.png>)

## Fifth task
Sudo означает SuperUser DO и используется для доступа к файлам и операциям с ограниченным доступом. По умолчанию Linux ограничивает доступ к определенным частям системы, предотвращая компрометацию конфиденциальных файлов. Команда sudo временно повышает привилегии, позволяя пользователям выполнять конфиденциальные задачи без входа в систему как пользователь root.
Даём разрешение пользователю NewUser на использование sudo.

![Alt text](<pic/screen27.png>)

    sudo hostname ...

![Alt text](<pic/screen28.png>)

## Sixth task
Выведи время часового пояса, в котором ты сейчас находишься.

![Alt text](<pic/screen29.png>)

Вывод следующей команды должен содержать NTPSynchronized=yes: 
timedatectl show

![Alt text](<pic/screen30.png>)

## Seventh task
Установить текстовые редакторы VIM (+ любые два по желанию NANO, MCEDIT, JOE и т.д.)
#### VIM
    sudo apt install vim

![Alt text](<pic/screen31.png>)

Жмём i, пишем, что нам надо, затем ctrl+C или Esc, затем команда :wq (для сохранения и выхода из редактора).

![Alt text](<pic/screen32.png>)

Повторяем команду с предыдушего снимка, жмём i, пишем(редактиурем), что нам надо, затем ctrl+C или Esc, затем команда :q! (для выхода из редактора без сохранения изменений).

![Alt text](<pic/screen33.png>)

Так же для переключения в режим редактирования используются такие команды:
    
    i - вставить текст с позиции курсора, символ под курсором будет заменен;
    I - вставить текст в начало строки;
    a - добавить текст начиная от позиции курсора;
    o - вставить новую строку после этой и начать редактирование; 
    O - вставить новую строку перед этой и начать редактирование;

Для поиска внутри редактора Vim нам нужно нажать клавишу с косой чертой(/), затем выполнить поиск по слову “слово”.:

    /слово
![Alt text](<pic/screen34.png>)

Мы можем использовать команду substitute редактора Vim для выполнения базовых и расширенных функций поиска и замены.
Команда substitute имеет следующий базовый синтаксис:

    :s/<search_phrase>/<replace_phrase>/options

![Alt text](<pic/screen35.png>)
![Alt text](<pic/screen36.png>)

Options включают c для подтверждения, i для игнорирования регистра и g для замены всех вхождений в одной линии.
Чтобы выполнить поиск и замену всех вхождений в каждой строке файла, нам нужно немного изменить предыдущую команду:

    :%s/<search_phrase>/<replace_phrase>/g

#### NANO
    sudo apt install nano

![Alt text](<pic/screen37.png>)

Чтобы сохранить изменения, внесенные в файл, нажмите Ctrl+o. Если файл еще не существует, он будет создан после его сохранения. Чтобы выйти из nano, нажмите Ctrl+x. Если есть несохраненные изменения, вас спросят, хотите ли вы сохранить изменения. Чтобы сохранить файл, у вас должны быть права на запись в файл. Если вы создаете новый файл, вам необходимо иметь разрешение на запись в каталог, в котором создается файл.

![Alt text](<pic/screen38.png>)
![Alt text](<pic/screen39.png>)

Чтобый выйти из редактора без сохранения, просто нажмите Ctrl + X. Если вы попытаетесь выйти без сохранения изменений, Nano напомнит вам, что есть некоторые несохраненные изменения. А так же потребует от вас принять меры. При нажатии кнопки «Y «, редактор сохранит изменения. А при нажатии копки «N» редактор 
проигнорирует сохранение изменений и выйдет из Nano.

![Alt text](<pic/screen40.png>)

Вообще там всё чёрныйм по белому написано, что и зачем жмать.

    Для поиска жмём  Сtrl+W. Курсор покажет на слово, которое мы ищем.

![Alt text](<pic/screen41.png>)
![Alt text](<pic/screen42.png>)
    
    Для замены Сtrl+\.

![Alt text](<pic/screen43.png>)
![Alt text](<pic/screen44.png>)
![Alt text](<pic/screen45.png>)

Я решила заменить все.

![Alt text](<pic/screen46.png>)

#### MCEDIT
    sudo apt install 
    
![Alt text](<pic/screen47.png>)

Пишем, что нам надо, затем жмём Fn2 для сохранения, вылезает панель, жмём на "сохранить", затем для выхода из редактора Fn10.

![Alt text](<pic/screen49.png>)

Пишем, что нам надо, затем для выхода из редактора без сохранения жмём Fn10. Вылезет окошко, в котором жмём "Нет".

![Alt text](<pic/screen50.png>)

С поиском и заменой у новичка проблем не возникнет. В нижней части панели ясно обозначено, что и для чего жмать. Для поиска символов Fn9. Для замены символов Fn4. На скриншотах видно, что 
вылезают окошки с доп опциями.

![Alt text](<pic/screen51.png>)
![Alt text](<pic/screen52.png>)
![Alt text](<pic/screen53.png>)

## Eighth task

SSH или Secure Shell - это протокол безопасного доступа из одного компьютера к другому по сети. У протокола SSH очень много возможностей. Вы можете создавать защищенные соединения между компьютерами, открывать командную строку на удаленном компьютере, запускать графические программы, передавать файлы и организовывать частные сети.

За поддержку протокола SSH в Linux отвечает набор программного обеспечения OpenSSH. Это открытая реализация этого протокола, которая предоставляет все необходимые возможности. В состав пакета OpenSSH входят утилиты для установки соединения, передачи файлов, а также сам ssh сервер.

    sudo apt install openssh-server
    
![Alt text](<pic/screen54.png>)

Будет загружено несколько пакетов, а когда установка ssh сервера Ubuntu завершится, программа будет готова к работе. Если вы хотите чтобы служба запускалась автоматически нужно добавить его в автозагрузку. Поэтому чтобы включить SSH в Ubuntu 20.04 выполните:

    sudo systemctl enable ssh
    systemctl status ssh

![Alt text](<pic/screen55.png>)
Настройки демона (Демон (daemon, dæmon, др.-греч. δαίμων) — компьютерная программа в UNIX-подобных системах, запускаемая самой системой и работающая в фоновом режиме без прямого взаимодействия с пользователем хранятся в файле /etc/ssh/sshd_config.

    sudo nano /etc/ssh/sshd-config

![Alt text](<pic/screen56.png>)
И ещё немного про то, как, собственно, пользоваться SSH. Для подключения к серверу используется команда: 

    ssh user_name@host_name, 

где user_name – имя пользователя в системе, host_name – имя узла, к которому производится подключение.

При этом утилита ssh запросит (в зависимости от настроек сервера) логин, пароль или парольную фразу для разблокировки приватного ключа пользователя.

Утилита ssh позволяет сразу выполнить нужную команду без открытия терминала удаленной машины. Например, команда: 

    ssh user@host ls 

выполнит команду ls на удаленном сервере и вернет ее вывод в текущий терминал.

Кроме выполнения команд, можно копировать файлы по ssh. Для этого используется утилита scp. Просто укажите файл, который нужно передать, удаленный сервер и папку на сервере, например: 
    
    scp ~/test.txt user@host:documents

#### ps
(processes status — статус процессов) — это встроенная утилита Unix/Linux для просмотра информации, касающейся выбора запущенных процессов в системе: она считывает эту информацию из виртуальных файлов в файловой системе /proc. Это одна из важных утилит для системного администрирования, особенно в рамках мониторинга процессов, чтобы помочь вам понять, что происходит в системе Linux.

В выводе присутствует четыре столбца:

    PID: идентификационный номер процесса.
    TTY: имя консоли, на которой пользователь выполнил вход.
    TIME: количество времени центрального процессора, которое потребил процесс.
    CMD: имя команды, которая запустила процесс

    ps опции
    $ ps опции | grep параметр

Во втором варианте мы используем утилиту grep для того, чтобы отобрать нужные нам процессы по определенному критерию. Теперь рассмотрим опции утилиты. Они делятся на два типа - те, которые идут с дефисом Unix и те, которые используются без дефиса - BSD. Лучше пользоваться только опциями Unix, но мы рассмотрим и одни и другие. Заметьте, что при использовании опций BSD, вывод утилиты будет организован в BSD стиле.

    -A, -e, (a) - выбрать все процессы;
    -a - выбрать все процессы, кроме фоновых;
    -d, (g) - выбрать все процессы, даже фоновые, кроме процессов сессий;
    -N - выбрать все процессы кроме указанных;
    -С - выбирать процессы по имени команды;
    -G - выбрать процессы по ID группы;
    -p, (p) - выбрать процессы PID;
    --ppid - выбрать процессы по PID родительского процесса;
    -s - выбрать процессы по ID сессии;
    -t, (t) - выбрать процессы по tty;
    -u, (U) - выбрать процессы пользователя.

Опции форматирования:

    -с - отображать информацию планировщика;
    -f - вывести максимум доступных данных, например, количество потоков;
    -F - аналогично -f, только выводит ещё больше данных;
    -l - длинный формат вывода;
    -j, (j) - вывести процессы в стиле Jobs, минимум информации;
    -M, (Z) - добавить информацию о безопасности;
    -o, (o) - позволяет определить свой формат вывода;
    --sort, (k) - выполнять сортировку по указанной колонке;
    -L, (H)- отображать потоки процессов в колонках LWP и NLWP;
    -m, (m) - вывести потоки после процесса;
    -V, (V) - вывести информацию о версии;
    -H - отображать дерево процессов;

Вводим 

    ps -e | grep sshd


![Alt text](<pic/screen57.png>)

#### NETSTAT
предназначена для получения сведений о состоянии сетевых соединений и слушаемых на данном компьютере портах TCP и UDP, а также, для отображения статистических данных по сетевым интерфейсам и протоколам.

Формат командной строки:

NETSTAT [-a] [-b] [-e] [-f] [-n] [-o] [-p протокол] [-r] [-s] [-t] [интервал]

Параметры командной строки:

-a - Отображение всех подключений и ожидающих портов.

-b - Отображение исполняемого файла, участвующего в создании каждого подключения, или ожидающего порта. Иногда известные исполняемые файлы содержат множественные независимые компоненты. Тогда отображается последовательность компонентов, участвующих в создании подключения, либо ожидающий порт. В этом случае имя исполняемого файла находится снизу в скобках [], сверху - компонент, который им вызывается, и так до тех пор, пока не достигается TCP/IP. Заметьте, что такой подход может занять много времени и требует достаточных разрешений.

-e - Отображение статистики Ethernet. Может применяться вместе с параметром -s.

-f - Отображение полного имени домена (FQDN) для внешних адресов.

-n - Отображение адресов и номеров портов в числовом формате.

-o - Отображение кода (ID) процесса каждого подключения.

-p протокол - Отображение подключений для протокола, задаваемых этим параметром. Допустимые значения: TCP, UDP, TCPv6 или UDPv6. Используется вместе с параметром -s для отображения статистики по протоколам. Допустимые значения: IP, IPv6, ICMP, ICMPv6, TCP, TCPv6, UDP или UDPv6.

-r - Отображение содержимого таблицы маршрутов.

-s - Отображение статистики протокола. По умолчанию статистика отображается для протоколов IP, IPv6, ICMP, ICMPv6, TCP, TCPv6, UDP и UDPv6. Параметр -p позволяет указать подмножество выводимых данных.

-t - Отображение текущего подключения в состоянии переноса нагрузки с процессора на сетевой адаптер при передаче данных ( "offload" ).

-v - Подробный вывод информации, если это возможно.
интервал - Повторный вывод статистических данных через указанный интервал в секундах. Для прекращения вывода данных нажмите клавиши CTRL+C. Если параметр не задан, сведения о текущей конфигурации выводятся один раз.


На практике, утилиту netstat.exe удобно использовать в цепочке с командами постраничного вывода (more), перенаправления стандартного вывода в файл ( > ) и поиска текста в результатах вывода ( find ).

netstat -a | more - отобразить все соединения в постраничном режиме вывода на экран.

netstat -a -n| more - то же, что и в предыдущем примере, но с отображением номеров портов и IP-адресов в числовом формате. В отличие от предыдущего примера, команда netstat с параметром -t отрабатывает намного быстрее.

netstat -a -f | more - то же, что и в предыдущем примере, но с отображением полных DNS-имен узлов, участвующих в соединениии.

netstat -a > C:\netstatall.txt - отобразить все соединения с записью результатов в файл C:\netstatall.txt.

netstat -a | find /I "LISTENING" - отобразить все соединения со статусом LISTENING, т.е. отобразить список сетевых интерфейсов и портов, ожидающих входящие соединения ( "слушаемых" портов ). Ключ /I в команде find указывает, что при поиске текста, не нужно учитывать регистр символов.

netstat -a | find /I "listening" > C:\listening.txt - отобразить все соединения со статусом LISTENING с записью результатов в файл C:\listening.txt.

    netstat -tan

![Alt text](<pic/screen58.png>)

Ключ -tan в команде netstat означает вывод всех активных сетевых соединений и их состояний в формате IP адресов и портов.

Значение каждого столбца вывода:

1. Протокол: Отображает протокол сетевого соединения (например, TCP или UDP).
2. Локальный адрес: Показывает IP адрес и порт на локальном компьютере.
3. Внешний адрес: Показывает IP адрес и порт удаленного компьютера.
4. Состояние: Отображает текущее состояние соединения (например, установлено, закрыто).

Значение 0.0.0.0:

IP адрес 0.0.0.0 указывает на то, что сетевое соединение прослушивает все доступные сетевые интерфейсы на компьютере, а не конкретный IP адрес. Это может быть использовано для сетевых приложений, которые хотят прослушивать все входящие соединения на компьютере.

## Ninth task

    sudo apt-get install top htop

#### TOP

    top

uptime - 1 min

количество авторизованных пользователей - 1 user

общую загрузку системы - 0,27 0,13 0,05

общее количество процессов - 98

загрузку cpu - третья строка

загрузку памяти - четвёртая и пятая строки

Допы:

    m -- команда выключения или переключения режима отображения информации о памяти
    F -- команда настройки полей с информацией о процессах
    L -- команда поиска по слову


pid процесса занимающего больше всего памяти - (В команде top: нажимаем M. И столбцы отсортируются по убыванию)

pid процесса, занимающего больше всего процессорного времени - (В команде top: нажимаем P. И столбцы отсортируются по убыванию по использованию CPU)

![Alt text](<pic/screen59.png>)

##### Первая строчка
отображает системное время, аптайм, количество активных пользовательских сессий и среднюю загруженность системы. Средняя загруженность для нас особенно важна, т.к дает понимание о среднем проценте утилизации ресурсов за некоторые промежутки времени.

Три числа показывают среднюю загрузку: за 1, 5 и 15 минут соответственно. Считайте, что эти числа - это процентная загрузка, т.е 0.2 означает 20%, а 1.00 - стопроцентную загрузку. Это звучит и выглядит достаточно логично, но иногда там могут проскакивать странные значения - вроде 2.50. Это происходит из-за того, что этот показатель не прямое значение загрузки процессора, а нечто вроде общего количества "работы", которое ваша система пытается выполнить. К примеру, значение 2.50 означает, что текущая загрузка равна 250% и ваша система на 150% перегружена.

##### Вторая строчка
достаточна понятна и просто показывает количество задач, запущенных в системе и их текущий статус.

##### Третья строчка
позволит вам отследить загрузку ЦПУ с подробной статистикой. Но здесь нужно сделать некоторые комментарии:

us: процент времени, когда ЦПУ был загружен и которое было затрачено на 
user space (созданные/запущенные пользователем процессы)

sy: процент времени, когда ЦПУ был загружен и которое было затрачено на на kernel (системные процессы)

ni: процент времени, когда ЦПУ был загружен и которое было затрачено на приоритезированные пользовательские процессы (системные процессы)

id: процент времени, когда ЦПУ не был загружен
wa: процент времени, когда ЦПУ ожидал отклика от устройств ввода - вывода 
(к примеру, ожидание завершения записи информации на диск)

hi: процент времени, когда ЦПУ получал аппаратные прерывания (например, от сетевого адаптера)

si: процент времени, когда ЦПУ получал программные прерывания (например, от какого-то приложения адаптера)

st: сколько процентов было "украдено" виртуальной машиной - в случае, если гипервизору понадобилось увеличить собственные ресурсы

##### Следующие две строчки
показывают сколько занято/свободно оперативно памяти и файла подкачки, и не так релевантны относительно задачи проверки нагрузки на процессор. Под информацией о памяти вы увидите список процессов и процент ЦПУ, который они тратят.

    MEMORY

![Alt text](<pic/screen60.png>)

    CPU

![Alt text](<pic/screen61.png>)


Колонки, которые выводит программа очень похожи на ps:

PID - идентификатор процесса;

USER - имя пользователя, от имени которого выполняется процесс;

PR - приоритет планировщика, установленный для процесса;

NI - рекомендуемый приоритет процесса. Это значение можно менять, может не совпадать с реальным приоритетом планировщика;

VIRT - всё, что находится в памяти, используется или зарезервировано для использования;

RES - всё, что находится в оперативной памяти и относится к процессу. Расшифровывается как Resident Memory Size, указывается в килобайтах;

SHR - часть памяти из RES, которую занимают ресурсы, доступные для использования другим процессам. Расшифровывается - Shared Memory Size.

S - состояние процесса: D - ожидает завершения операции, R - запущен, S - спит, T - остановлен, t - остановлен отладчиком, Z - зомби;

%CPU - процент использования ресурсов процессора;

%MEM - процент использования ресурсов оперативной памяти на основе колонки RES;

TIME - обще процессорное время, которое процесс использовал с момента запуска;

COMAND - команда, с помощью которой был запущен процесс.

#### HTOP

В отчёт вставь скрин с выводом команды htop:

    отсортированному по PID, PERCENT_CPU, PERCENT_MEM, TIME - F6

![Alt text](<pic/screen62.png>)
![Alt text](<pic/screen63.png>)
![Alt text](<pic/screen64.png>)
![Alt text](<pic/screen65.png>)

    отфильтрованному для процесса sshd - F3
    
![Alt text](<pic/screen66.png>) 

    с процессом syslog, найденным, используя поиск
    
![Alt text](<pic/screen67.png>) 
    
    с добавленным выводом hostname, clock и uptime - F2

![Alt text](<pic/screen68.png>) 
![Alt text](<pic/screen69.png>) 

## Tenth task

    sudo fdisk -l

название жесткого диска VBOX HARDDISK

его размер 50 Gb

количество секторов 104857600


![Alt text](<pic/screen70.png>) 

    free -h 

размер swap 3.8G

![Alt text](<pic/screen71.png>) 


## Eleventh task

#### df

df опции устройство

Устройство указывать необязательно, но можно указать раздел диска, о котором мы хотим посмотреть информацию. А теперь рассмотрим основные опции утилиты:

    -a, --all - отобразить все файловые системы, в том числе виртуальные, псевдо и недоступные;
    -B - изменить размер одного блока перед выводом данных, например, можно использовать BM, чтобы вывести все данные в мегабайтах;
    -h - выводить размеры в читаемом виде, в мегабайтах или гигабайтах;
    -H - выводить все размеры в гигабайтах;
    -i - выводить информацию об inode;
    -k - выводить размеры в килобайтах;
    --output - использовать специальный формат вывода, если не задано, выводит все поля. Доступны такие варианты: 'source', 'fstype', 'itotal', 'iused', 'iavail', 'ipcent', 'size', 'used', 'avail', 'pcent', 'file' и 'target';
    -P - использовать формат вывода POSIX;
    --total - выводить всю информацию про использованное и доступное место;
    -t, --type - выводить информацию только про указанные файловые системы;
    -x - выводить информацию обо всех, кроме указанных файловых систем;
    Теперь, после основных опций рассмотрим подробнее как примеры df linux.

![Alt text](<pic/screen72.png>) 

В отчёте напиши для корневого раздела (/):

    размер раздела - 51287520
    размер занятого пространства - 7488960
    размер свободного пространства - 41160892
    процент использования - 16%

Определи и напиши в отчёт единицу измерения в выводе: байты

![Alt text](<pic/screen73.png>) 

В отчёте напиши для корневого раздела (/):

    размер раздела - 49G 
    размер занятого пространства - 7,2G
    размер свободного пространства - 40G
    процент использования - 16%

Определи и напиши в отчёт тип файловой системы для раздела: ext4


## Twelfth task

du опции /путь/к/папке

А вот опции утилиты:

    -a, --all - выводить размер для всех файлов, а не только для директорий, по умолчанию размер выводится только для папок;
    -B, --block-size - указать единицы вывода размера, доступно: K,M,G,T,P,E,Z,Y для 1024 и KB, MB и так далее для 1000;
    -c, --total - выводить в конце общий размер всех папок;
    -d, --max-depth - максимальная глубина вложенности директорий;
    -h, --human-readable - выводить размер в единицах измерения удобных для человека;
    --inodes - выводить информацию об использованию inode;
    -L, --dereference - следовать по всем символическим ссылкам;
    -l, --count-links - учитывать размер файла несколько раз для жестких ссылок;
    -P, --no-dereference - не следовать по символическим ссылкам, это поведение используется по умолчанию;
    -S, --separate-dirs - не включать размер подпапок в размер папки;
    --si - выводить размер файлов и папок в системе си, используется 1000 вместо 1024;
    -s, --summarize - выводить только общий размер;
    -t, --threshold - не учитывать файлы и папки с размером меньше указанного;
    --time - отображать время последней модификации для файла или папки, вместо времени модификации можно выводить такие метки: atime, access, use, ctime;
    -X, --exclude - исключить файлы из подсчёта;
    -x, --one-file-system - пропускать примонтированные файловые системы;
    --version - вывести версию утилиты.

Запусти команду du

![Alt text](<pic/screen74.png>) 

Выведи размер папок /home, /var, /var/log (в байтах, в человекочитаемом виде)

![Alt text](<pic/screen75.png>) 

Выведи размер всего содержимого в /var/log (не общее, а каждого вложенного элемента, используя *)

![Alt text](<pic/screen76.png>) 

## Thirteenth task

Системные журналы - это файлы, в которых хранятся все события и процессы, происходящие с файлами, работа оборудования и т.д. 
Системных журналов много и все они расположены в директории /var/log/. 
Чтобы посмотреть логи, удобно использовать несколько утилит командной строки Linux. Вот команды, которые чаще всего используются для этих целей:

    less - просмотр логов с помощью прокрутки
    more
    cat - открытие лог файла
    head -  просмотр первых строк лога
    grep
    tail - просмотр логов в реальном времени
    zcat
    zgrep
    zmore
    vi
    nano

##### Утилита ncdu
Это псевдографическая утилита, которая работает в терминале Linux. Она отображает список файлов и директорий по объёму и, что самое интересное, тут же позволяет удалять ненужные файлы. Для установки утилиты выполните:

    sudo apt install ncdu

Для перехода в выбранную директорию используйте одну из следующих кнопок:

    курсор вправо
    ENTER
    l


Для возврата в родительскую директорию используйте одну из следующих кнопок:

    курсор влево
    <
    h


Для сортировки директорий и файлов используются следующие кнопки (нажмите ещё раз для обратного порядка):

    n — по имени файла
    s — по размеру файла
    C — по количеству элементов
    M — по времени модификации последнего дочернего элемента

![Alt text](<pic/screen77.png>) 

    ncdu /home

![Alt text](<pic/screen78.png>) 

    sudo ncdu /var

![Alt text](<pic/screen79.png>) 

    sudo ncdu /var/log

![Alt text](<pic/screen80.png>) 

## Fourteenth task

    vim /var/log/dmesg

![Alt text](<pic/screen81.png>) 

    vim /var/log/syslog

![Alt text](<pic/screen82.png>) 

    vim /var/log/auth.log

![Alt text](<pic/screen83.png>) 

    sudo systemctl restart ssh
    sudo grep "sshd*" /var/log/auth.log

![Alt text](<pic/screen84.png>) 

    sudo grep "session opened" /var/log/auth.log

![Alt text](<pic/screen85.png>) 

Последняя успешная авторизация - Feb 6 20:38:58

Имя пользователя -  volchok

Метод входа - локальный вход, с исползованием логина и пароля под правами root

## Fifteenth task
#### CRON 

Настройка 

Для настройки времени, даты и интервала когда нужно выполнять задание используется специальный синтаксис файла cron и специальная команда. Конечно, вы всегда можете отредактировать файл /etc/crontab, но этого делать не рекомендуется. Вместо этого, есть команда crontab:

    crontab -e

Ее всегда желательно выполнять с опцией -e, тогда для редактирования правил будет использован ваш текстовый редактор по умолчанию. Команда открывает вам временный файл, в котором уже представлены все текущие правила cron и вы можете добавить новые. После завершения работы команды cron файл будет обработан и все правила будут добавлены в /var/spool/cron/crontabs/имя_пользователя причем добавленные процессы будут запускаться именно от того пользователя, от которого вы их добавляли.

Поэтому тут нужно быть аккуратным, и если вам нужно выполнять скрипты от рута, то и crontab нужно выполнить от рута, а не от пользователя. Это часто становится причиной проблем.

Синтаксис crontab

    минута час день месяц день_недели /путь/к/исполняемому/файлу

Нужно сказать, что обязательно нужно писать полный путь к команде, потому что для команд, запускаемых от имени cron переменная среды PATH будет отличаться, и сервис просто не сможет найти вашу команду. Это вторая самая распространенная причина проблем с Cron. Дата и время указываются с помощью цифр или символа '*'. Этот символ означает, что нужно выполнять каждый раз, если в первом поле - то каждую минуту и так далее.

Синтаксис и операторы Crontab
Crontab (таблица cron) — это текстовый файл, определяющий расписание заданий cron. Файлы Crontab можно создавать, просматривать , изменять и удалять с помощью команды crontab .

Каждая строка в пользовательском файле crontab содержит шесть полей, разделенных пробелом, за которым следует команда, которую нужно запустить:

    * * * * * command(s)
    ^ ^ ^ ^ ^
    | | | | |     allowed values
    | | | | |     -------
    | | | | ----- Day of week (0 - 7) (Sunday=0 or 7)
    | | | ------- Month (1 - 12)
    | | --------- Day of month (1 - 31)
    | ----------- Hour (0 - 23)
    ------------- Minute (0 - 59)

Первые пять полей (время и дата) также принимают следующие операторы:

    * — оператор звездочки означает все допустимые значения. Если у вас есть символ звездочки в поле Минуты, это означает, что задача будет выполняться каждую минуту.
    - — Оператор дефиса позволяет указать диапазон значений. Если вы установите 1-5 в поле «День недели», задача будет запускаться каждый будний день (с понедельника по пятницу). Диапазон является включительным, что означает, что первое и последнее значения включены в диапазон.
    , — Оператор запятой позволяет определить список значений для повторения. Например, если в поле «Час» указано 1,3,5 , задача будет выполняться в 1, 3 и 5 утра. Список может содержать отдельные значения и диапазоны, 1-5,7,8,10-15
    / — оператор косой черты позволяет указать значения шага, которые можно использовать вместе с диапазонами. Например, если в поле «Минуты» указано 1-10/2 , это означает, что действие будет выполняться каждые две минуты в диапазоне 1–10, как и при указании 1,3,5,7,9 . Вместо диапазона значений вы также можете использовать оператор звездочки. Чтобы указать задание, которое будет запускаться каждые 20 минут, вы можете использовать «* / 20».
    Синтаксис общесистемных файлов crontab немного отличается от пользовательских файлов crontab. Он содержит дополнительное обязательное пользовательское поле, в котором указывается, какой пользователь будет запускать задание cron.

    * * * * * <username> command(s)

Запускать задание Cron каждые 2 минуты

Первый вариант — использовать оператор запятой для создания списка минут:

    0,2,4,6,8,10,12, ..., 58  * * * * command

Вышеприведенная строка синтаксически верна и будет работать нормально. Однако ввод всего списка может быть утомительным и подверженным ошибкам.

Второй вариант указать задание, которое будет запускаться каждые 2 минуты часов, — это использовать оператор step:

    */2  * * * * command

*/2 означает создание списка всех минут и запуск задания для каждого второго значения из списка.

![Alt text](<pic/screen86.png>) 
![Alt text](<pic/screen87.png>) 


##### Примеры настройки cron
Сначала можно посмотреть задачи cron для суперпользователя, для этого можно воспользоваться опцией -l:

    crontab -l

Вы можете удалить все существующие задачи командой -r:

    crontab -r

![Alt text](<pic/screen88.png>) 