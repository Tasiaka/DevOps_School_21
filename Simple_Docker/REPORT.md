## Part 1. Готовый докер

    docker builder	    Управление сборками
    docker checkpoint	Управление контрольными точками
    docker compose	    
    docker config	    Управление конфигурациями Swarm
    docker container	Управление контейнерами
    docker context	    Управление контекстами
    docker debug	    Создайте оболочку в любом контейнере или образе. Альтернатива отладке с помощью `docker exec`.
    docker image	    Управление изображениями
    docker init	        Создает стартовые файлы, связанные с Docker, для вашего проекта
    docker inspect	    Возвращает низкоуровневую информацию об объектах Docker
    docker login	    Войдите в реестр
    docker logout	    Выход из реестра
    docker manifest	    Управление манифестами образов Docker и списками манифестов
    docker network	    Управление сетями
    docker node	        Управление узлами Swarm
    docker plugin	    Управление плагинами
    docker scout	    Инструмент командной строки для Docker Scout
    docker search	    Поиск изображений в Docker Hub
    docker secret	    Управление секретами Swarm
    docker service  	Управление сервисами Swarm
    docker stack	    Управление стеками Swarm
    docker swarm    	Управление Swarm
    docker system	    Управление Docker
    docker trust    	Управление доверием к изображениям Docker
    docker version  	Показать информацию о версии Docker
    docker volume   	Управление томами

Для начала я установлю Docker на свою машину 

Вход в реестр
    
    docker login
    docker login localhost:8080

![Alt text](<pic/1.png>)

##### Возьми официальный докер-образ с nginx и выкачай его при помощи docker pull.

    docker image pull [OPTIONS] NAME[:TAG|@DIGEST]

    -a, --all-tags		Загрузите все изображения с тегами в репозиторий
    --disable-content-trust	true	Пропустить проверку изображения
    --platform		API 1.32+ Установите платформу, поддерживает ли сервер мультиплатформенность
    -q, --quiet		Подавлять подробный вывод

![Alt text](<pic/2.png>)

##### Проверь наличие докер-образа через docker images.

    cker image build	    Создайте изображение из файла Dockerfile
    docker image history	Показать историю изображения
    docker image import 	Импортируйте содержимое из архива для создания образа файловой системы
    docker image inspect	Отображение подробной информации на одном или нескольких изображениях
    docker image load	    Загрузите изображение из архива tar или STDIN
    docker image prune	    Удалить неиспользуемые изображения
    docker image rm	        Удалите одно или несколько изображений
    docker image save	    Сохраните одно или несколько изображений в tar-архиве (по умолчанию они передаются в стандартный вывод).
    docker image tag	    Создайте тег TARGET_IMAGE, который ссылается на SOURCE_IMAGE
    docker image ls	        Список изображений
    docker image pull	    Загрузить изображение из реестра
    docker image push	    Загрузка изображения в реестр

![Alt text](<pic/3.png>)

Команда 'docker images' выводит список образов верхнего уровня (top-level images). Фактически, ничего особенного не отличает образ от слоя для чтения. Только те образы, которые имеют присоединенные контейнеры или те, что были получены с помощью pull, считаются образами верхнего уровня. Это различие нужно для удобства, так как за каждым образом верхнего уровня может быть множество слоев.

Команда 'docker images -a' выводит все образы на хост-машине. Это фактически список всех слоев для чтения в системе. Если вы хотите увидеть все слои одного образа, воспользуйтесь командой 'docker history'.

##### Запусти докер-образ через docker run -d [image_id|repository].

    docker container run [OPTIONS] IMAGE [COMMAND] [ARG...]

![Alt text](<pic/4.png>)

##### Проверь, что образ запустился через docker ps.

![Alt text](<pic/5.png>)

##### Посмотри информацию о контейнере через docker inspect [container_id|container_name].
начало

![Alt text](<pic/6.png>)

конец 

![Alt text](<pic/7.png>)

	docker inspect [OPTIONS] NAME|ID [NAME|ID...]

Docker inspect предоставляет подробную информацию о конструкциях, управляемых Docker.
По умолчанию docker inspect будет отображать результаты в виде массива JSON.

##### По выводу команды определи и помести в отчёт размер контейнера, список замапленных портов и ip контейнера.

![Alt text](<pic/8.png>) - 64 Mb
![Alt text](<pic/10.png>) 
![Alt text](<pic/11.png>)

##### Останови докер образ через docker stop [container_id|container_name].

![Alt text](<pic/9.png>) 

##### Проверь, что образ остановился через docker ps.


##### Запусти докер с портами 80 и 443 в контейнере, замапленными на такие же порты на локальной машине, через команду run.

Чтобы открыть доступ к этим портам, мы должны использовать флаг -p в нашей команде запуска docker. После флага -p указаны порт хоста и порт контейнера. Итак, если бы мы хотели сопоставить порт 80 на хосте с портом 80 в контейнере, мы бы использовали -p 80:80.

    docker run -d --name=web_server -p 80:80 -p 443:443 nginx

![Alt text](<pic/12.png>)

##### Проверь, что в браузере по адресу localhost:80 доступна стартовая страница nginx.

![Alt text](<pic/13.png>)

##### Перезапусти докер контейнер через docker restart [container_id|container_name].

![Alt text](<pic/14.png>)

    docker run [опции] [образ] [команда]

Утилите обязательно надо передать образ, на основе которого будет создан контейнер. Образ может быть локальным или указывать на образ, который надо загрузить из сети. Мы рассмотрим это в примерах ниже. Опции позволяют настроить контейнер и параметры его запуска более детально. Сама команда позволяет переопределить программу, которая выполняется после запуска контейнера. Например, выполнив /bin/bash, вы можете подключится к самому контейнеру.

Рассмотрим основные опции утилиты, которые мы будем использовать. Опций очень много, поэтому я не могу перечислить их все:

    -d - запускает контейнер в фоновом режиме;
    -t - прикрепляет к контейнеру псевдо-TTY-консоль;
    -i - выводит в терминал STDIN поток контейнера;
    --name - имя контейнера, по которому потом можно будет к нему обращаться;
    --dns - устанавливает DNS-серверы для контейнера;
    --network - тип сети для контейнера, может принимать такие значения: bridge (используется по умолчанию), none, host. Также можно передать идентификатор сети Docker, к которой надо подключится;
    --add-host - добавляет строчку в /etc/hosts;
    --restart - указывает, когда надо перезапускать контейнер. Возможные значения: no, on-failure, always, unless-stopped;
    --rm - удаляет контейнер после завершения его работы;
    -m, --memory - количество оперативной памяти, доступное Docker-контейнеру;
    --memory-swap - объём памяти раздела подкачки, доступный в контейнере;
    --cpus - количество ядер процессора, доступных в контейнере;
    --shm-size - размер файла /dev/shm;
    --device - позволяет монтировать устройства из папки /dev в контейнер;
    --entrypoint - позволяет переопределить скрипт, который выполняется при запуске контейнера, перед запуском основной команды;
    --expose - позволяет пробросить несколько портов из контейнера в хост-систему;
    -P - пробрасывает все порты контейнера в хост-систему;
    -p - переносит все порты контейнера в хост-систему без смены номера порта;
    --link - позволяет настроить связь контейнеров Docker;
    -e - добавляет переменную окружения в контейнер;
    -v, --volume - позволяет монтировать папки хоста в контейнер;
    -w - изменяет рабочую директорию контейнера.


## Part 2. Операции с контейнером

##### Прочитай конфигурационный файл nginx.conf внутри докер контейнера через команду exec.

Запустить интерактивную оболочку в контейнере Docker (возможно, для изучения файловой системы или отладки запущенных процессов) можно с помощью docker exec с флагами -i и -t.

Флаг -i открывает ввод для контейнера, а -t создает псевдо-терминал, к которому может подключиться оболочка. Эти флаги можно комбинировать следующим образом:

    docker exec -it container-name sh

![Alt text](<pic/15.png>)

##### Создай на локальной машине файл nginx.conf.

##### Настрой в нем по пути /status отдачу страницы статуса сервера nginx.

Создайте серверный блок по умолчанию
Проверьте в своей конфигурации NGINX наличие блока default_server. Если у вас его еще нет, давайте создадим его. Вставьте следующий блок в свой блок конфигурации http.

Создайте серверный блок по умолчанию
Проверьте в своей конфигурации NGINX наличие блока default_server. Если у вас его еще нет, давайте создадим его. Вставьте следующий блок в свой блок конфигурации http.


##### Скопируй созданный файл nginx.conf внутрь докер-образа через команду docker cp.

    Usage:  docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-
        docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH

Copy files/folders between a container and the local filesystem

Use '-' as the source to read a tar archive from stdin
and extract it to a directory destination in a container.
Use '-' as the destination to stream a tar archive of a
container source to stdout.

Aliases:
  docker container cp, docker cp

    Options:
    -a, --archive       Archive mode (copy all uid/gid information)
    -L, --follow-link   Always follow symbol link in SRC_PATH
    -q, --quiet         Suppress progress output during copy. Progress
                        output is automatically suppressed if no terminal is
                        attached


##### Перезапусти nginx внутри докер-образа через команду exec.

Команда 'docker exec' применяется к запущенному контейнеру, запускает новый процесс внутри пространства процессов контейнера.

    docker inspect <container-id> | <image-id>

Перезапускаем Nginx внутри контейнера (допустим, что наш контейнер называется nginx-server)

    docker exec -it nginx-server nginx -s reload

##### Проверь, что по адресу localhost:80/status отдается страничка со статусом сервера nginx.

![Alt text](<pic/17.png>)

![Alt text](<pic/16.png>)

###### Экспортируй контейнер в файл container.tar через команду export.

###### Останови контейнер.

##### Удали образ через docker rmi [image_id|repository], не удаляя перед этим контейнеры.

    docker rmi [параметры удаления] [ID образов]

Параметры у неё такие:

    --force или -f: принудительно удалить образ;
    --no-prune: не удалять непомеченные (не связанные по TAG) родителей;

##### Удали остановленный контейнер.

Для удаления контейнеров используется команда docker container rm или просто docker rm. Для наглядности будем использовать docker container rm с таким синтаксисом:

    docker container rm [параметры удаления] [ID объектов]

Параметры:

    --force или -f: принудительное устранение контейнера (например, если он работает);
    --link или -l: удалить указанную ссылку (например, между двумя объектами)*;
    --volume или -v: удалить связанные с контейнером анонимные тома;

![Alt text](<pic/19.png>)

![Alt text](<pic/20.png>)

##### Импортируй контейнер обратно через команду import.

    docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]

Вы можете указывает URL или - (тире), чтобы получать данные непосредственно из STDIN . URL может указывать на архив (.tar, .tar.gz, .tgz, .bzip, .tar.xz или .txz), содержащий файловую систему, или на отдельный файл на хосте Docker. Если указывает архив, Docker распаковывает его в контейнере относительно / (root). Если вы указываете отдельный файл, вы должны указывает полный путь на хосте. Для импорта из удаленного расположения указывает URI, начинающийся с протокола http:// или https://.

Параметр --change применяет инструкции Dockerfile к создаваемому образу. Поддерживаемые инструкции Dockerfile: CMD | ENTRYPOINT | ENV | EXPOSE | ONBUILD | USER | VOLUME | WORKDIR

Примеры использования этой команды см. в разделе примеров далее.

    --change, -c Примените инструкцию Dockerfile к созданному образу
    --message, -m Устанавливает сообщение фиксации для импортированного образа
    --platform Устанавливает платформу, если сервер поддерживает несколько платформ

![Alt text](<pic/21.png>)

##### Запусти импортированный контейнер.

##### Проверь, что по адресу localhost:80/status отдается страничка со статусом сервера nginx.

![Alt text](<pic/22.png>)

![Alt text](<pic/23.png>)


## Part 3. Мини веб-сервер

##### Напиши мини-сервер на C и FastCgi, который будет возвращать простейшую страничку с надписью Hello World!.

FastCGI

FastCGI (Fast Common Gateway Interface) - это протокол, который позволяет веб-серверам общаться с приложениями, написанными на различных языках программирования. Он был разработан для повышения производительности и масштабируемости веб-приложений.

FastCGI работает следующим образом:

Веб-сервер запускает менеджер FastCGI, который прослушивает сокеты.
При поступлении запроса веб-сервер передает его менеджеру FastCGI.
Менеджер FastCGI запускает процесс FastCGI для обработки запроса.
Процесс FastCGI обрабатывает запрос и возвращает ответ менеджеру FastCGI.
Менеджер FastCGI передает ответ веб-серверу.
Веб-сервер отправляет ответ клиенту.

##### Запусти написанный мини-сервер через spawn-fcgi на порту 8080.

spawn-fcgi - это менеджер процессов FastCGI, который используется для запуска и управления процессами FastCGI. Он является частью проекта lighttpd, но может использоваться с любым веб-сервером, который поддерживает FastCGI.

![Alt text](<pic/24.png>)

Для MacOS
![Alt text](<pic/25.png>)

![Alt text](<pic/26.png>)
![Alt text](<pic/27.png>)
![Alt text](<pic/28.png>)
![Alt text](<pic/29.png>)
![Alt text](<pic/30.png>)

##### Напиши свой nginx.conf, который будет проксировать все запросы с 81 порта на 127.0.0.1:8080.

![Alt text](<pic/32.png>)
![Alt text](<pic/31.png>)

##### Проверь, что в браузере по localhost:81 отдается написанная тобой страничка.

![Alt text](<pic/33.png>)

## Part 4. Свой докер

##### Напиши свой докер-образ, который:

##### 1) собирает исходники мини сервера на FastCgi из Части 3;

##### 2) запускает его на 8080 порту;

##### 3) копирует внутрь образа написанный ./nginx/nginx.conf;

##### 4) запускает nginx.
nginx можно установить внутрь докера самостоятельно, а можно воспользоваться готовым образом с nginx'ом, как базовым.

##### Собери написанный докер-образ через docker build при этом указав имя и тег.

![Alt text](<pic/33.png>)
![Alt text](<pic/34.png>)

##### Проверь через docker images, что все собралось корректно.

![Alt text](<pic/35.png>)
![Alt text](<pic/36.png>)

##### Запусти собранный докер-образ с маппингом 81 порта на 80 на локальной машине и маппингом папки ./nginx внутрь контейнера по адресу, где лежат конфигурационные файлы nginx'а (см. Часть 2).

![Alt text](<pic/37.png>)

##### Проверь, что по localhost:80 доступна страничка написанного мини сервера.

![Alt text](<pic/38.png>)

##### Допиши в ./nginx/nginx.conf проксирование странички /status, по которой надо отдавать статус сервера nginx.

![Alt text](<pic/39.png>)

##### Перезапусти докер-образ.Если всё сделано верно, то, после сохранения файла и перезапуска контейнера, конфигурационный файл внутри докер-образа должен обновиться самостоятельно без лишних действий

![Alt text](<pic/41.png>)

##### Проверь, что теперь по localhost:80/status отдается страничка со статусом nginx

![Alt text](<pic/40.png>)

## Part 5. Dockle

    brew install goodwithtech/r/dockle

##### Просканируй образ из предыдущего задания через dockle [image_id|repository].

![Alt text](<pic/42.png>)

##### Исправь образ так, чтобы при проверке через dockle не было ошибок и предупреждений.

CIS-DI-0001: Create a user for the container:
    был root, стал meow + USER строка сместилась ниже

DKL-DI-0005: Clear apt-get caches:

После установки или обновления пакетов с помощью apt-get, очистить кэш командой rm -rf /var/lib/apt/lists/*, чтобы уменьшить размер образа Docker

CIS-DI-0006: Add HEALTHCHECK instruction to the container image:

Добавьте инструкцию HEALTHCHECK в ваш образ Docker, чтобы проверять состояние контейнера

    HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 CMD curl -f http://localhost/ || exit 1

    --interval=30s: Указывает интервал, с которым будет выполняться проверка (в данном случае каждые 30 секунд).
    --timeout=10s: Устанавливает таймаут для каждой проверки (10 секунд).
    --start-period=5s: Время ожидания перед началом проверок (5 секунд).
    --retries=3: Количество попыток перед тем, как контейнер будет помечен как недоступный.
    В данном примере используется команда curl -f http://localhost/ || exit 1, которая проверяет доступность веб-сервера на localhost. Вы можете заменить эту команду на любую другую, соответствующую вашим потребностям.

![Alt text](<pic/44.png>)

    добавила исключения на ключи nginx в вызове dockle, так как они необходимы


## Part 6. Базовый Docker Compose

    brew install docker-compose

Docker Compose - это инструмент для определения и запуска многоконтейнерных приложений в Docker. Он позволяет описывать структуру и зависимости между контейнерами приложения в файле YAML, а затем запускать всю структуру одной командой. Docker Compose автоматизирует процесс настройки окружения для разработки, тестирования и развертывания приложений, упрощая управление контейнерами и их взаимодействие.

##### Напиши файл docker-compose.yml, с помощью которого:

##### 1) Подними докер-контейнер из Части 5 (он должен работать в локальной сети, т.е. не нужно использовать инструкцию EXPOSE и мапить порты на локальную машину).

##### 2) Подними докер-контейнер с nginx, который будет проксировать все запросы с 8080 порта на 81 порт первого контейнера.

прописываю всё для второго контейнера

![Alt text](<pic/45.png>)
![Alt text](<pic/46.png>)
![Alt text](<pic/47.png>)
![Alt text](<pic/48.png>)

##### Замапь 8080 порт второго контейнера на 80 порт локальной машины.

##### Собери и запусти проект с помощью команд docker-compose build и docker-compose up.

![Alt text](<pic/49.png>)

##### Проверь, что в браузере по localhost:80 отдается написанная тобой страничка, как и ранее.

![Alt text](<pic/50.png>)
